<?php // -*- php -*-


/* FIXME

Make explicit somehow the assumptiopns about node types?
bundles: committee_role with field_email_address, field_copy_emails_to
user profiles have a role called 'committee' and a profile2 called 'committee_profile'
*/

/**
 * Implements hook_libraries_info().
 *
 * Defines a dependency on the Google API's PHP client library.
 */
function eltmc_googlesync_libraries_info() {

    // Expected to be extracted into 'sites/all/libraries/google-api-php-client'.
    $libraries['google-api-php-client'] = array(
        'name' => 'Client Library for Google APIs',
        'vendor url' => 'http://developers.google.com/api-client-library/php',
        'download url' => 'https://github.com/google/google-api-php-client/archive/master.zip',
        'version arguments' => array(
            'file' => 'src/Google/Client.php',
            'pattern' => '/LIBVER *= *[\'"]([0-9.]*)[\'"]/',
            'lines' => 100,
        ),
        'versions' => array(
            '1.1.3' => array(),
        ),
        'files' => array(
            'php' => array('src/Google/autoload.php'),
        ),
    );

    return $libraries;
}


function _eltmc_googlesync_libraries_load() {

    $name = 'google-api-php-client';
    $library = libraries_load($name);
    if ($library &&
        !empty($library['installed'])) {
        return true;
    }
    else {
        // Something went wrong. :(
        $error = $library['error']? $library['error'] : "unknown";
        // Get a detailed (localized) error message.
        $message = $library['error message']? $library['error message'] : "Failed to load library $name";
        watchdog('eltmc_googlesync', $message);
        drupal_set_message($message, $error);
        return false;
    }
}
/**
 * Loads the configuration parameters we need from Drupal's database.
 *
 * Returns an array of values, or null if anything fails.
 */
function _eltmc_googlesync_get_config() {

    global $_eltmc_googlesync_stub_config;
    if ($_eltmc_googlesync_stub_config !== null)
        return $_eltmc_googlesync_stub_config;

    // optional params are set to false
    // 'case sensitive' means mandatory, and don't lowercase
    $params = array(
        'domain' => true,
        'client_email' => true,
        'private_key_json' => 'case sensitive',
        'google_admin_account' => true,
        'groups_admin_account' => false,
        'dryrun' => false,
    );

    $config = array();
    foreach ($params as $param => $required) {
        $value = variable_get("eltmc_googlesync_$param");
        if ($required && !isset($value))
            return null;
        if ($required !== 'case sensitive')
            $value = strtolower($value);
        $config[$param] = $value;
    }

    return $config;
}


/**
 * Gets a Google API client instance.
 *
 * Assumes the requisite Google API library has already been loaded.
 * Also that the paramters have been validated.
 *
 * Loads a cached authentication token from the Drupal variable
 * eltmc_googlesync_access_token.  Caches a (possibly new)
 * authentication token there afterwards.
 *
 * @param $config  An assosiative array containing the following attributes:
 *
 * domain               The Google Apps domain
 * client_email         The client email as supplied by google dev
 * console.
 *
 * google_admin_account The Google Apps admin account to impersonate
 *
 * private_key_json     The private key from google dev console,
 * JSON format.  Must be an object with a private_key field, which is
 * a OpenSSL ascii-armoured private key (including the BEGIN PRIVATE
 * KEY delimiters).
 *
 * @returns A client instance, or null if the $config is null or the
 * google API missing.
 * Should not thrown any exceptions.
 */
function _eltmc_googlesync_get_client($config) {

    if (!$config)
        return null;

    if (!_eltmc_googlesync_libraries_load())
        return null;

    // Convert the JSON private key into a form we can pass to the
    // Google API
    $data = json_decode($config['private_key_json']);
    if (!$data || !$data->private_key) {
        watchdog('eltmc_googlesync', 
                 "<p>There is no private_key field in the configured private key JSON value</p>");
        return null;
    }

    try {
        $client = new Google_Client();
        $client->setApplicationName("eltmc_googlesync");

        // Load cached access token, if any
        $access_token = variable_get('eltmc_googlesync_access_token');
        if (isset($access_token))
            $client->setAccessToken($access_token);
        
        $scopes = array('https://www.googleapis.com/auth/admin.directory.group.member',
		        'https://www.googleapis.com/auth/admin.directory.group',
		        'https://www.googleapis.com/auth/admin.directory.user',
		        'https://www.googleapis.com/auth/admin.directory.user.alias');
        $credentials = new Google_Auth_AssertionCredentials(
            $config['client_email'],
            $scopes,
            $data->private_key,
            'notasecret' // Default key password
        );
        $credentials->sub = $config['google_admin_account'];
        $client->setAssertionCredentials($credentials);

        // Authenticate, if token is expired
        if ($client->getAuth()->isAccessTokenExpired()) {
            $client->getAuth()->refreshTokenWithAssertion();
        }

        // Cache the token for re-use
        variable_set('eltmc_googlesync_access_token', $client->getAccessToken());    
        return $client;
    }
    catch(Excption $ex) {
        $message = t("<p>Error getting authenticating with Google:</p><pre>%exception</pre> ",
                     array('%exception' => $ex));
        watchdog('eltmc_googlesync', $message);
        drupal_set_message($message, 'error');
        return null;
    }
}


function _eltmc_googlesync_get_email_name($email) {
    $name = preg_match('/^(.*)@/', $email, $matches);
    return $matches[1];
}

function _eltmc_googlesync_endswith($string, $test) {
    $strlen = strlen($string);
    $testlen = strlen($test);
    if ($testlen > $strlen) return false;
    return substr_compare($string, $test, -$testlen) === 0;
}

function _eltmc_googlesync_norm_email($email) {
    return strtolower(trim($email));
}

/**
 * Implements hook_menu
 */
function eltmc_googlesync_menu() {

    $items = array();

    $items['admin/config/services/eltmc_googlesync'] = array(
        'title' => 'ELTMC Google Sync module settings',
        'description' => 'Configure synchronisation',
        'page callback' => 'drupal_get_form',
        'page arguments' => array('eltmc_googlesync_admin_form'),
        'access arguments' => array('access administration pages'),
        'type' => MENU_NORMAL_ITEM,
    );

    return $items;
}

/**
 * Defines the admin configuration form
 */
function eltmc_googlesync_admin_form() {

    $form = array(
        'eltmc_googlesync_manage_domains' => array(
            '#markup' =>
                t("Before configuring this module, you will need to create a Google Apps ".
                  "domain, which at the time of writing are unfortunatly no longer free ".
                  "(see <a href='http://support.google.com/a/bin/answer.py?hl=en&answer=2855120'>".
                  "here</a> for some more information).  You then need to FIXME add it to your ".
                  "managed domains at <a href='https://accounts.google.com/ManageDomains'>".
                  "https://accounts.google.com/ManageDomains</a>, and follow the steps to ".
                  "obtain a Consumer Secret and Consumer Key."),
        ),
        'eltmc_googlesync_domain' => array(
            '#type' => 'textfield',
            '#title' => t('Google Apps domain name'),
            '#default_value' => variable_get('eltmc_googlesync_domain', ''),
            '#size' => 50,
            '#maxlength' => 100,
            '#description' => t("The name of your Google Apps domain, e.g. edinburghtwins.co.uk"),
            '#required' => TRUE,
        ),
        'eltmc_googlesync_client_email' => array(
            '#type' => 'textfield',
            '#title' => t('Google API client email'),
            '#default_value' => variable_get('eltmc_googlesync_client_email', ''),
            '#size' => 100,
            '#maxlength' => 200,
            '#description' => t("The client email obtained from Google Apps."),
            '#required' => TRUE,
        ),
        'eltmc_googlesync_google_admin_account' => array(
            '#type' => 'textfield',
            '#title' => t('Google Apps admin user'),
            '#default_value' => variable_get('eltmc_googlesync_google_admin_account', ''),
            '#size' => 100,
            '#maxlength' => 100,
            '#description' => t("The Google Apps admin account to use when connecting (give the account's email address, e.g. drupal@edinburghtwins.co.uk)."),
            '#required' => TRUE,
        ),
        'eltmc_googlesync_private_key_json' => array(
            '#type' => 'textarea',
            '#title' => t('The private key.'),
            '#default_value' => variable_get('eltmc_googlesync_private_key_json', ''),
            '#size' => 50,
            '#maxlength' => 2000,
            '#description' => t("The private key obtained from Google, in JSON format."),
            '#required' => TRUE,
        ),
        'eltmc_googlesync_groups_admin_account' => array(
            '#type' => 'textfield',
            '#title' => t('The groups admin email address.'),
            '#default_value' => variable_get('eltmc_googlesync_groups_admin', ''),
            '#size' => 50,
            '#maxlength' => 100,
            '#description' => t("If set, all groups will have this email address set as owner."),
            '#required' => FALSE,
        ),
        'eltmc_googlesync_dryrun' => array(
            '#type' => 'checkbox',
            '#title' => t("Dry-run mode."),
            '#default_value' => variable_get('eltmc_googlesync_dryrun', true),
            '#description' => t("If checked, the module's action, when executed, won't actually modify the groups, just log what it would have done"),
            '#required' => FALSE,
        ),
        'eltmc_googlesync_action_note' => array(
            '#markup' => "<p>You can bind the <i>eltmc_googlesync_sync_groups_to_committee_action</i> ".
                "to a trigger <a href='/admin/config/system/actions'>here</a>, ".
                "or if the <a href='http://drupal.org/project/rules'>Rules</a> module is installed, ".
                "probably more flexibly use that instead.</p>"
        ),
    );

    // FIXME add help explaining how to get the secret etc.

    return system_settings_form($form);
}



/**
 * Implements hook_action_info().
 */
function eltmc_googlesync_action_info() {
    return array(
        'eltmc_googlesync_sync_groups_to_committee_action' => array(
            'label' => t('Synchronise the Google App domain email groups with the current committee occupants.'),
            'type' => 'system',
            'configurable' => FALSE,
            'triggers' => array('any'),
        ),
    );
}


/**
 * Find users with a given role.
 * Adapted from http://drupal.stackexchange.com/questions/11175/get-all-users-with-specific-roles-using-entityfieldquery
 *
 * @param $role mixed           The name or rid of the role we're wanting users to have
 * @param $active_user boolean  Only return active accounts?
 *
 * @return array An array of user objects with the role
 */
function _eltmc_googlesync_uids_with_role($role, $active_user = TRUE) {
    $uids = array();
    $users = array();
    if (is_int($role)) {
        $my_rid = $role;
    }
    else {
        $role = user_role_load_by_name($role);
        $my_rid = $role->rid;
    }
    $result = db_select('users_roles', 'ur')
        ->fields('ur', array('uid'))
        ->condition('ur.rid', $my_rid, '=')
        ->execute();

    return $result->fetchCol();
}



/**
 * Find all committee_role nodes, and append them to the $groups hash,
 * adding a recipient email for both $groups_admin_address, and all
 * of the addresses listed in the field_copy_emails_to field.
 *
 * @param array $group_admin_addresses An array of recipients all the groups should send to.  Should be at least one of these.
 * @return array An array mapping committee_role emails to recipient email addresses.
 */
function _eltmc_googlesync_create_recipient_map($group_admin_addresses, $config) {
    $groups = array();

    // Get all the committee_role nodes
    $query = new EntityFieldQuery();
    $query
        ->entityCondition('entity_type', 'node')
        ->entityCondition('bundle', 'committee_role');


    $result = $query->execute();

    if (!isset($result['node'])) {
        return null;
    }

    $roles_nids = array_keys($result['node']);
    $roles = entity_load('node', $roles_nids);

    // For each committee_role
    foreach($roles as $role) {

        // Get the role's email address
        $items = field_get_items('node', $role, 'field_email_address');

        if (!$items || count($items) == 0) continue;

        // Mark the $groups_admin_address as a recipient
        $email_address = _eltmc_googlesync_norm_email($items[0]['email']);

        foreach($group_admin_addresses as $admin_address) {
            $groups[$email_address][$admin_address] = true;
        }

        // Get all the CC To field addresses
        $items = field_get_items('node', $role, 'field_copy_emails_to');
        if (!$items) continue;

        foreach($items as $cc_address) {
            // Add this CC To address as another recipient
            $cc_address = _eltmc_googlesync_norm_email($cc_address['email']);
            $groups[$email_address][$cc_address] = true;
        }
    }


    // Get the Committee's UIDs
    $uids = _eltmc_googlesync_uids_with_role('committee');
    $errors = array();

    // Add their email addresses and comittee roles into the hash-of-hashes $groups
    foreach ($uids as $uid) {
        $user = user_load($uid);
        $profile = profile2_load_by_user($uid, 'committee_profile');
        if (!$profile) continue;

        $items = field_get_items('profile2', $profile, 'field_committee_roles');
        if (!$items) continue;

        foreach($items as $c_role) {
            $node = node_load($c_role['target_id']);
            $items2 = field_get_items('node', $node, 'field_email_address');
            if (!$items2) continue;

            $group_name  = _eltmc_googlesync_norm_email($items2[0]['email']);
            $groups[$group_name][_eltmc_googlesync_norm_email($user->mail)] = true;
            if (!_eltmc_googlesync_endswith($group_name, '@'.$config['domain'])) {
                $errors[] = "<li>Group $group_name does not end with your Google Apps domain!</li>";
            }
        }
    }

    if (count($errors) > 0) {
        $message = t("<p>Querying committee_role emails aborted because of problems detected:</p><ul>!errors</ul>",
                     array('!errors' => implode($errors, "\n")));
        watchdog('eltmc_googlesync', $message);
        return null;
    }

    return $groups;
}




/**
 * This implements the action which perform the synchronisation.
 * Essentially it just invokes the function which does the job and logs the result.
 */
function eltmc_googlesync_sync_groups_to_committee_action() {
    $message = eltmc_googlesync_sync_groups_to_committee();
    watchdog('eltmc_googlesync', $message);
    drupal_set_message($message, 'status');
}

/**
 * Retrieves an associative hash of user accounts, mapping both primary and
 * alias email addresses of all users to the account's primary email address.
 */
function _eltmc_googlesync_gapps_users($service, $config) {
    $user_emails = array();
    $user_params = array('domain' => $config['domain'],
                         'maxResults' => 500); // 500 is the max maxResult

    do {
        $results = $service->users->listUsers($user_params);

        foreach ($results->getUsers() as $item) {
            // also $item->emails[*]->address
            // echo "$item->primaryEmail ".$item->name['fullName']."\n";
            $primary = _eltmc_googlesync_norm_email($item->primaryEmail);
            $user_emails[$primary] = $primary;
            foreach ($item->emails as $alias) {
                $alias = _eltmc_googlesync_norm_email($alias['address']);
                $user_emails[$alias] = $primary;
            }
        }
        $user_params['pageToken'] = $results->nextPageToken;
    } while($user_params['pageToken']);

    return $user_emails;
}

/**
 * Retrieves an associative array of associative arrays, mapping group
 * email addresses to member email addresses to member role ('OWNER'
 * or 'MEMBER').  (All email addresses are lowercased).
 */
function _eltmc_googlesync_gapps_groups($service, $config) {
    $gapps_groups = array();

    $group_params = array('domain' => $config['domain'],
                          'maxResults' => 500);
    do {

        $gapps_group_list = $service->groups->listGroups($group_params);

        $member_page = null;        
        foreach ($gapps_group_list->getGroups() as $group) {

            $member_params = array('maxResults' => 500);
            do {
                $member_list = $service->members->listMembers($group->email, $member_params);

                //dpm("group id $group->email: ".print_r($member_list, true)); // DEBUG
                $member_map = array();
                foreach($member_list->getMembers() as $member) {
                    $member_map[_eltmc_googlesync_norm_email($member->email)] = $member->role;
                }
                
                $gapps_groups[_eltmc_googlesync_norm_email($group->email)] = $member_map;

                $member_params['pageToken'] = $member_list->nextPageToken;
            } while($member_params['pageToken']);

        }
        
        $group_params['pageToken'] = $gapps_group_list->nextPageToken;

    } while($group_params['pageToken']);
    
    return $gapps_groups;
}    

function _eltmc_googlesync_gapps_create_group($service, $config, $group_email) {
    $group_name = ucfirst(_eltmc_googlesync_get_email_name($group_email));
    $group = new Google_Service_Directory_Group(array(
        'email' => $group_email,
        'name' => $group_name,
    ));
    
    $service->groups->insert($group);
}

function _eltmc_googlesync_gapps_add_member_to_group($service, $config, $user_email, $role, $group_email) {
    $member = new Google_Service_Directory_Member(array(
        'role' => $role,
        'email' => $user_email,
    ));
    $service->members->insert($group_email, $member);
}

function _eltmc_googlesync_gapps_delete_group($service, $config, $group_email) {
    $service->groups->delete($group_email);
}

function _eltmc_googlesync_gapps_remove_member_from_group($service, $config, $user_email, $group_email) {
    $service->members->delete($group_email, $user_email);
}

function _eltmc_googlesync_gapps_update_member($service, $config, $user_email, $role, $group_email) {
    $member = new Google_Service_Directory_Member(array(
        'role' => $role,
    ));
    $service->members->patch($group_email, $user_email, $member);
}

function _eltmc_googlesync_committee_emails($groups) {
}

/**
 * This actually performs the synchronisation, if $dryrun is false, or
 * $dryrun is null and the drupal variable eltmc_googlesync_dryrun is false.
 */
function _eltmc_googlesync_sync_groups_to_committee($dryrun = null) {

    $config = _eltmc_googlesync_get_config();
    if (!$config) {
        watchdog('eltmc_googlesync', "<p>Not yet configured fully, skipping group sync</p>");
        return;
    }
    if ($dryrun === null) {
        $dryrun = $config['dryrun'];
    }

    $client = _eltmc_googlesync_get_client($config);
    if (!$client) {
        watchdog('eltmc_googlesync', "<p>Failed to get a Google API client</p>");
        return;
    }

    $service = new Google_Service_Directory($client);

    // Create an array $group_admins whose keys are the group admin(s).
    // For now, we just allow a single (optional) shared group admin.
    $groups_admin = $config['groups_admin_account'];
    $group_admins = array();
    if ($groups_admin) $group_admins[$groups_admin] = true;

    // Create an assoc array mapping committe_role official emails to
    // assoc arrays of users' email addresses (whose keys are
    // important, but the values are ignored)
    $groups = _eltmc_googlesync_create_recipient_map(array_keys($group_admins), $config);

    
    // Get Google Apps idea of user accounts and aliases
    $gapps_users = _eltmc_googlesync_gapps_users($service, $config);
    //    dpm(print_r($gapps_users, true)); // DEBUG

    // And it's idea of groups and membership information
    $gapps_groups = _eltmc_googlesync_gapps_groups($service, $config);
    //    dpm(print_r($gapps_groups, true)); // DEBUG

    $delta = array();

    // Add any new groups/memberships into Google
    foreach ($groups as $group_email => $users) {

        // Skip groups which have the same name as a user account
        // (we can't define a group for those)
        if (array_key_exists($group_email, $gapps_users)) {
            $delta[$group_email]['MODIFICATION'] = 'not created as it is in use by a user account or alias';
            continue;
        }

        if (!array_key_exists($group_email, $gapps_groups)) {
            $delta[$group_email]['MODIFICATION'] = 'created';
            $gapps_groups[$group_email] = array();
            try {
                if (!$dryrun)
                    _eltmc_googlesync_gapps_create_group($service, $config, $group_email);
            }
            catch (Exception $ex) {
                $delta[$group_email]['MODIFICATION'] .= " - failed: ".$ex->getMessage();
            }
        }

        foreach ($users as $user_email => $role) {
            if (array_key_exists($user_email, $gapps_groups[$group_email]))
                continue;

            if (!array_key_exists($group_email, $delta) || !array_key_exists('MODIFICATION', $delta[$group_email]))
                $delta[$group_email]['MODIFICATION'] = 'modified';

            try {
                // If the user is in the $groups_admin array, make them an owner
                if (array_key_exists($user_email, $group_admins)) {
                    $delta[$group_email][$user_email] = 'added as an owner';

                    if (!$dryrun)
                        _eltmc_googlesync_gapps_add_member_to_group($service, $config, $user_email, 'OWNER', $group_email);
                }
                else {
                    // Just make them a normal member
                    $delta[$group_email][$user_email] = 'added as a member';

                    if (!$dryrun)
                        _eltmc_googlesync_gapps_add_member_to_group($service, $config, $user_email, 'MEMBER', $group_email);
                }
            }
            catch (Exception $ex) {
                $delta[$group_email][$user_email] .= " - failed: ".$ex->getMessage();
            }
        }
    }

    // Delete groups/memberships which no longer exist from Google
    foreach ($gapps_groups as $group_email => $users) {

        // Skip groups which have the same name as a user account
        // (we can't delete a group for those)
        if (array_key_exists($group_email, $gapps_users)) {
            $delta[$group_email]['MODIFICATION'] = 'not deleted as it is in use by a user account or alias';
            continue;
        }

        if (!array_key_exists($group_email, $groups)) {
            $delta[$group_email]['MODIFICATION'] = 'removed';

            try {
                if (!$dryrun)
                    _eltmc_googlesync_gapps_delete_group($service, $config, $group_email);
            }
            catch (Exception $ex) {
                $delta[$group_email]['MODIFICATION'] .= " - failed: ".$ex->getMessage();
            }

            continue;
        }

        foreach ($users as $user_email => $role) {
            try {
                if (!array_key_exists($user_email, $groups[$group_email])) {
                    $delta[$group_email][$user_email] = 'removed';

                    if (!$dryrun)
                        _eltmc_googlesync_gapps_remove_member_from_group($service, $config, $user_email, $group_email);
                }
                elseif (array_key_exists($user_email, $group_admins) &&
                        $role !== 'OWNER') {
                    // Promote user to owner
                    $delta[$group_email][$user_email] = 'promoted to owner';
                    if (!$dryrun)
                        _eltmc_googlesync_gapps_update_member($service, $config, $user_email, 'OWNER', $group_email);
                }
                elseif(!array_key_exists($user_email, $group_admins) &&
                        $role === 'OWNER') {
                    // Demote user from owner
                    $delta[$group_email][$user_email] = 'demoted to ordinary member';
                    if (!$dryrun)
                        _eltmc_googlesync_gapps_update_member($service, $config, $user_email, 'MEMBER', $group_email);
                }
                else {
                    // Skip the rest of this loop body
                    continue;
                }
            }
            catch (Exception $ex) {
                $delta[$group_email][$user_email] .= " - failed: ".$ex->getMessage();
            }

            if (!array_key_exists($group_email, $delta) || !array_key_exists('MODIFICATION', $delta[$group_email]))
                $delta[$group_email]['MODIFICATION'] = 'modified';
        }
    }

    return $delta;
}


function eltmc_googlesync_sync_groups_to_committee()
{
    $delta = _eltmc_googlesync_sync_groups_to_committee();
    if (!$delta)
        return;

    // HTMLise the $delta entries. Report the changes.
    ksort($delta);
    $log = '<ul>';
    foreach($delta as $group => $groupdelta) {
        $group = t($group);
        $modification = array_key_exists('MODIFICATION', $groupdelta)?
            $groupdelta['MODIFICATION'] : '';
        unset($groupdelta['MODIFICATION']);

        $log .= "<li> Group $group $modification</li>";

        if (count($groupdelta) > 0) {
            $log .= '<ul>';
            foreach($groupdelta as $user => $modification) {
                $user = t($user);

                $log .= "<li> User $user $modification</li>";
            }
            $log .= '</ul>';
        }
    }
    $log .= '</ul>';

    $message = t("<p>!modified Google Group configurations:</p><ul>!actions</ul>",
                 array('!actions' => $log,
                       '!modified' => $dryrun? "<i>Dry-run</i>: would have modified" : "Modified"));

    return $message;
}

